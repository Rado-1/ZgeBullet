<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Comment="ZgeBullet demo #1. Created by Rado1" Caption="Physics Demo 1" FrameRateStyle="1" ScreenMode="0" CameraPosition="-48.0318 10 35.9576" CameraRotation="0 2.1477 0" ViewportRatio="3" ClipFar="800" MouseVisible="255" NoSound="1" AndroidPackageName="com.rado1.PhysicsDemo1">
  <OnLoaded>
    <ZExternalLibrary Comment="Bullet 3D physics" ModuleName="ZgeBullet" CallingConvention="1" BeforeInitExp="if(ANDROID) this.ModuleName = &quot;./libZgeBullet.so&quot;;">
      <Source>
<![CDATA[/*
  ZgeBullet Library, a wrapper for the Bullet Physics Library.
  http://bulletphysics.org

  Project home
  https://github.com/Rado-1/ZgeBullet

  Download Windows DLL and Android shared library from
  http://googledrive.com/host/0BxwfQ8la88ouQTVuLWJfY1dMVGs/

  Copyright (c) 2012-2015 Radovan Cervenka

  Version: 2.0 (2015-06-08)
*/


// Constants

// Triangle mesh types
const int ZBT_TRIANGLE_CONVEX_HULL_MESH = 1;
const int ZBT_TRIANGLE_CONCAVE_STATIC_MESH = 2;
const int ZBT_TRIANGLE_CONCAVE_DEFORMABLE_MESH = 3;

// Activation states
const int ZBT_ACTIVE_TAG = 1;
const int ZBT_ISLAND_SLEEPING = 2;
const int ZBT_WANTS_DEACTIVATION = 3;
const int ZBT_DISABLE_DEACTIVATION = 4;
const int ZBT_DISABLE_SIMULATION = 5;

// Default values of constraint limits
const float ZBT_DEFAULT_HINGE_SOFTNESS = 0.9;
const float ZBT_DEFAULT_HINGE_BIAS_FACTOR = 0.3;
const float ZBT_DEFAULT_HINGE_RELAXATION_FACTOR = 1.0;
const float ZBT_DEFAULT_CONE_TWIST_SOFTNESS = 1.0;
const float ZBT_DEFAULT_CONE_TWIST_BIAS_FACTOR = 0.3;
const float ZBT_DEFAULT_CONE_TWIST_RELAXATION_FACTOR = 1.0;

// Vehicle tunning defaults
const float ZBT_DEFAULT_VEHICLE_SUSP_STIFFNESS = 5.88;
const float ZBT_DEFAULT_VEHICLE_SUSP_COMPRESSION = 0.83;
const float ZBT_DEFAULT_VEHICLE_SUSP_DAMPING = 0.88;
const float ZBT_DEFAULT_VEHICLE_SUSP_MAX_SUSP_TRAVEL_CM = 500.0;
const float ZBT_DEFAULT_VEHICLE_SUSP_FORCE = 6000.0;
const float ZBT_DEFAULT_VEHICLE_FRICTION_SLIP = 10.5;

// Axes
const int ZBT_AXIS_X_LINEAR = 0;
const int ZBT_AXIS_Y_LINEAR = 1;
const int ZBT_AXIS_Z_LINEAR = 2;
const int ZBT_AXIS_X_ANGULAR = 3;
const int ZBT_AXIS_Y_ANGULAR = 4;
const int ZBT_AXIS_Z_ANGULAR = 5;

// Collision flags
const int ZBT_CF_STATIC_OBJECT= 1;
const int ZBT_CF_KINEMATIC_OBJECT= 2;
const int ZBT_CF_NO_CONTACT_RESPONSE = 4;
const int ZBT_CF_CUSTOM_MATERIAL_CALLBACK = 8;
const int ZBT_CF_CHARACTER_OBJECT = 16;
//const int ZBT_CF_DISABLE_VISUALIZE_OBJECT = 32;
const int ZBT_CF_DISABLE_SPU_COLLISION_PROCESSING = 64;


// Functions

void zbtCreateWorld() {}

void zbtDestroyWorld() {}

void zbtSetWorldGravity(float x, float y, float z) {}

void zbtStepSimulation(float timeStep, int maxSubSteps, float fixedTimeStep) {}


// Collision shapes
xptr zbtCreateStaticPlaneShape(
	float normalX, float normalY, float normalZ, float planeConstant) {}

xptr zbtCreateBoxShape(float x, float y, float z) {}

xptr zbtCreateSphereShape(float radius) {}

xptr zbtCreateScalableSphereShape(float radius) {}

xptr zbtCreateConeShape(float radius, float height) {}

xptr zbtCreateCylinderShape(float radius, float height) {}

xptr zbtCreateCapsuleShape(float radius, float height) {}

xptr zbtCreateCompoundShape() {}

xptr zbtAddChildShape(xptr compoundShape, xptr childShape,
	float x, float y, float z, float rx, float ry, float rz) {}

xptr zbtRemoveChildShape(xptr compoundShape, xptr childShape) {}

xptr zbtCreateHeightfieldTerrainShape(xptr heightfieldData,
	int width, int length, float minHeight, float maxHeight, int upAxis,
	int bFlipQuadEdges, int bDiamondSubdivision) {}

xptr zbtCreateConvexHullShape(xptr points, int numPoints) {}

xptr zbtCreateMultiSphereShape(xptr positions, xptr radii, int numSpheres) {}

xptr zbtCreateTriangleMeshShape(xptr triangles, int numTriangles, int meshType) {}

void zbtUpdateDeformableTriangleMesh(xptr triangleMeshShape) {}

void zbtSetShapeLocalScaling(xptr shape, float x, float y, float z) {}

void zbtSetShapeMargin(xptr shape, float margin) {}

void zbtDeleteShape(xptr shape) {}

void zbtDeleteAllShapes() {}


// Rigid bodies

xptr zbtCreateRigidBodyXYZ(float mass, xptr shape,
	float x, float y, float z, float rx, float ry, float rz) {}

xptr zbtCreateRigidBody(float mass, xptr shape, xptr position, xptr rotation) {}

void zbtDeleteRigidBody(xptr rigidBody) {}

void zbtSetMass(xptr rigidBody, float mass) {}

void zbtSetDamping(xptr rigidBody, float linearDamping, float angularDamping) {}

void zbtSetLinearFactor(xptr rigidBody, float x, float y, float z) {}

void zbtSetAngularFactor(xptr rigidBody, float x, float y, float z) {}

void zbtSetGravity(xptr rigidBody, float x, float y, float z) {}

void zbtSetLinearVelocity(xptr rigidBody, float x, float y, float z) {}

void zbtGetLinearVelocity(xptr rigidBody,
	ref float outX, ref float outY, ref float outZ) {}

void zbtSetAngularVelocity(xptr rigidBody, float x, float y, float z) {}

void zbtGetAngularVelocity(xptr rigidBody,
	ref float outX, ref float outY, ref float outZ) {}

void zbtApplyCentralImpulse(xptr rigidBody, float x, float y, float z) {}

void zbtApplyTorqueImpulse(xptr rigidBody, float x, float y, float z) {}

void zbtApplyImpulse(xptr rigidBody, float x, float y, float z,
	float relX, float relY, float relZ) {}

void zbtSetSleepingThresholds(xptr rigidBody, float linear, float angular) {}


// Constraints and limits

int zbtAreConnected(xptr rigidBodyA, xptr rigidBodyB) {}

xptr zbtAddFixedConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float rotAx, float rotAy, float rotAz,
	float rotBx, float rotBy, float rotBz, int bDisableCollision) {}

xptr zbtAddPoint2PointConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ) {}

xptr zbtAddPoint2PointConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz, int bDisableCollision) {}

xptr zbtAddHingeConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ,
	float axisX, float axisY, float axisZ) {}

xptr zbtAddHingeConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float axisAx, float axisAy, float axisAz,
	float axisBx, float axisBy, float axisBz, int bDisableCollision) {}

void zbtSetHingeLimits(xptr hinge, float low, float high,
	float softness, float biasFactor, float relaxationFactor) {}

void zbtEnableHingeAngularMotor(xptr hinge, int bEnableMotor,
	float targetVelocity, float maxMotorImpulse) {}

xptr zbtAddConeTwistConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ,
	float rotX, float rotY, float rotZ) {}

xptr zbtAddConeTwistConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float rotAx, float rotAy, float rotAz,
	float rotBx, float rotBy, float rotBz, int bDisableCollision) {}

void zbtSetConeTwistLimits(xptr twist, float swingSpanA, float swingSpanB,
	float twistSpan, float damping, float softness, float biasFactor,
	float relaxationFactor) {}

void zbtEnableConeTwistMotor(xptr twist,
	int bEnableMotor, float maxMotorImpulse,
	float targetX, float targetY, float targetZ) {}

xptr zbtAddSliderConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ,
	float rotX, float rotY, float rotZ,
	int bUseLinearReferenceWorldFrame) {}

xptr zbtAddSliderConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float rotAx, float rotAy, float rotAz,
	float rotBx, float rotBy, float rotBz,
	int bUseLinearReferenceFrameA, int bDisableCollision) {}

void zbtSetSliderLimits(xptr slider,
	float linLower, float linUpper, float angLower, float angUpper) {}

void zbtSetSliderSoftness(xptr slider,
	float dirLin, float dirAng, float limLin, float limAng,
	float orthoLin, float orthoAng) {}

void zbtSetSliderRestitution(xptr slider,
	float dirLin, float dirAng, float limLin, float limAng,
	float orthoLin, float orthoAng) {}

void zbtSetSliderDamping(xptr slider,
	float dirLin, float dirAng, float limLin, float limAng,
	float orthoLin, float orthoAng) {}

void zbtEnableSliderLinearMotor(xptr slider, int bEnableMotor,
	float targetVelocity, float maxForce) {}

void zbtEnableSliderAngularMotor(xptr slider, int bEnableMotor,
	float targetVelocity, float maxForce) {}

xptr zbtAddGearConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float axisAx, float axisAy, float axisAz,
	float axisBx, float axisBy, float axisBz,
	float ratio) {}

void zbtSetGearConstraint(xptr gear,
	float axisAx, float axisAy, float axisAz,
	float axisBx, float axisBy, float axisBz,
	float ratio) {}

xptr zbtAddGeneric6DofConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ,
	float rotX, float rotY, float rotZ,
	int bUseLinearReferenceWorldFrame) {}

xptr zbtAddGeneric6DofConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float rotAx, float rotAy, float rotAz,
	float rotBx, float rotBy, float rotBz,
	int bUseLinearReferenceFrameA, int bDisableCollision) {}

void zbtSetGeneric6DofLimits(xptr dof, int axis, float lower, float upper) {}

void zbtSetGeneric6DofLinearLimits(xptr dof,
	float lowerX, float lowerY, float lowerZ,
	float upperX, float upperY, float upperZ) {}

void zbtSetGeneric6DofAngularLimits(xptr dof,
	float lowerX, float lowerY, float lowerZ,
	float upperX, float upperY, float upperZ) {}

xptr zbtAddGeneric6DofSpringConstraint1(xptr rigidBody,
	float pivotX, float pivotY, float pivotZ,
	float rotX, float rotY, float rotZ,
	int bUseLinearReferenceWorldFrame) {}

xptr zbtAddGeneric6DofSpringConstraint(xptr rigidBodyA, xptr rigidBodyB,
	float pivotAx, float pivotAy, float pivotAz,
	float pivotBx, float pivotBy, float pivotBz,
	float rotAx, float rotAy, float rotAz,
	float rotBx, float rotBy, float rotBz,
	int bUseLinearReferenceFrameA, int bDisableCollision) {}

void zbtSetGeneric6DofSpring(xptr spring,
	int axis, int bEnableSpring, float stiffness, float damping,
	float equilibriumPoint) {}

void zbtDeleteConstraint(xptr constraint) {}


// Raycast vehicle

void zbtSetVehicleTunning(float suspStiffness, float suspCompression,
	float suspDamping, float maxSuspTravelCm, float maxSuspForce,
	float frictionSlip) {}

xptr zbtCreateRaycastVehicle(xptr carChassis,
	int rightAxis, int upAxis, int forwardAxis) {}

int zbtAddWheel(xptr vehicle,
	float connectionPointX, float connectionPointY, float connectionPointZ,
	float directionX, float directionY, float directionZ,
	float wheelAxleX, float wheelAxleY, float wheelAxleZ,
	float wheelRadius, float suspRestLength, int bIsFrontWheel) {}

void zbtSetWheelIsFront(xptr vehicle, int wheelId, int bIsFront) {}

void zbtSetWheelRadius(xptr vehicle, int wheelId, float radius) {}

void zbtSetWheelRollInfluence(xptr vehicle, int wheelId, float rollInfluence) {}

void zbtSetWheelFrictionSlip(xptr vehicle, int wheelId, float frictionSlip) {}

void zbtSetWheelSuspRestLength(xptr vehicle, int wheelId, float suspRestLength) {}

void zbtSetWheelMaxSuspTravel(xptr vehicle, int wheelId, float maxSuspTravel) {}

void zbtSetWheelSuspStiffness(xptr vehicle, int wheelId, float suspStiffness) {}

void zbtSetWheelDampingCompression(xptr vehicle, int wheelId,
	float dampingCompression) {}

void zbtSetWheelDampingRelaxation(xptr vehicle, int wheelId,
	float dampingRelaxation) {}

void zbtSetWheelSteering(xptr vehicle, int wheelId, float steering) {}

void zbtSetWheelEngineForce(xptr vehicle, int wheelId, float force) {}

void zbtSetWheelBrake(xptr vehicle, int wheelId, float brake) {}

void zbtResetVehicleSusp(xptr vehicle) {}

float zbtGetVehicleCurrentSpeed(xptr vehicle) {}

void zbtGetWheelPositionXYZ(xptr vehicle, int wheelId,
	ref float outX, ref float outY, ref float outZ) {}

void zbtGetWheelPosition(xptr vehicle, int wheelId, xptr outPosition) {}

void zbtGetWheelRotationXYZ(xptr vehicle, int wheelId,
	ref float outRx, ref float outRy, ref float outRz) {}

void zbtGetWheelRotation(xptr vehicle, int wheelId, xptr outRotation) {}

void zbtGetWheelPosRotXYZ(xptr vehicle, int wheelId,
	ref float outX, ref float outY, ref float outZ,
	ref float outRx, ref float outRy, ref float outRz) {}

void zbtGetWheelPosRot(xptr vehicle, int wheelId,
	xptr outPosition, xptr outRotation) {}

void zbtDeleteRaycastVehicle(xptr vehicle) {}


// Ghost object

xptr zbtCreateGhostObject(xptr shape,
	float x, float y, float z, float rx, float ry, float rz) {}

void zbtDeleteGhostObject(xptr ghostObject) {}

int zbtGetNumOverlappingObjects(xptr ghostObject) {}

xptr zbtGetOverlappingObject(xptr ghostObject, int index) {}


// Kinematic character controller

xptr zbtCreateKinematicCharacterController(
	xptr ghostObject, float stepHeight) {}

void zbtDeleteKinematicCharacterController(xptr controller) {}

void zbtSetCharacterUpAxis(xptr controller, int axis) {}

void zbtSetCharacterWalkDirection(xptr controller,
	float x, float y, float z) {}

void zbtSetCharacterVelocityForTimeInterval(xptr controller,
	float x, float y, float z, float timeInterval) {}

void zbtCharacterWarp(xptr controller, float x, float y, float z) {}

void zbtSetCharacterFallSpeed(xptr controller, float fallSpeed) {}

void zbtSetCharacterJumpSpeed(xptr controller, float jumpSpeed) {}

void zbtSetCharacterMaxJumpHeight(xptr controller, float maxJumpHeight) {}

int zbtCharacterCanJump(xptr controller) {}

void zbtCharacterJump(xptr controller) {}

void zbtSetCharacterGravity(xptr controller, float gravity) {}

void zbtSetCharacterMaxSlope(xptr controller, float slope) {}

void zbtSetCharacterUseGhostSweepTest(xptr controller,
	int bUseGhostObjectSweepTest) {}

int zbtCharacterOnGround(xptr controller) {}

void zbtCharacterReset(xptr controller) {}

void zbtSetCharacterUpInterpolate(xptr controller, int bInterpolate) {}


// Collision objects (in general)

void zbtSetFriction(xptr obj, float friction) {}

void zbtSetRestitution(xptr obj, float restitution) {}

void zbtSetHitFraction(xptr obj, float hitFraction) {}

void zbtGetPositionXYZ(xptr obj,
	ref float outX, ref float outY, ref float outZ) {}

void zbtGetPosition(xptr obj, xptr outPosition) {}

void zbtSetPosition(xptr obj, float x, float y, float z) {}

void zbtGetRotationXYZ(xptr obj,
	ref float outRx, ref float outRy, ref float outRz) {}

void zbtGetRotation(xptr obj, xptr outRotation) {}

void zbtSetRotation(xptr obj, float rx, float ry, float rz) {}

void zbtGetPosRotXYZ(xptr obj,
	ref float outX, ref float outY, ref float outZ,
	ref float outRx, ref float outRy, ref float outRz) {}

void zbtGetPosRot(xptr obj, xptr outPosition, xptr outRotation) {}

void zbtSetCollisionFlags(xptr obj, int flags) {}

int zbtIsActive(xptr obj) {}

void zbtActivate(xptr obj, int bForceActivation) {}

void zbtSetActivationState(xptr obj, int newState) {}

void zbtForceActivationState(xptr obj, int newState) {}

void zbtSetDeactivationTime(xptr obj, float time) {}

void zbtSetUserIndex(xptr obj, int index) {}

int zbtGetUserIndex(xptr obj) {}

void zbtSetUserPointer(xptr obj, xptr pointer) {}

xptr zbtGetUserPointer(xptr obj) {}


// Collision detection

void zbtSetIgnoreCollisionCheck(xptr objA, xptr objB,
	int bIgnoreCollisionCheck) {}

int zbtStartCollisionDetection() {}

int zbtGetNextContact(xptr outObjA, xptr outObjB,
	xptr outPosA, xptr outPosB, xptr outNormal) {}

void zbtGetCollidedObjects(int contactIndex, xptr outObjA, xptr outObjB) {}

int zbtIsColliding(xptr obj) {}

int zbtGetNumberOfCollisions(xptr obj) {}

int zbtIsCollidedWith(xptr objA, xptr objB) {}


// Raycasting

xptr zbtRayTest(float fromX, float fromY, float fromZ, float toX, float toY, float toZ) {}

void zbtGetRayTestHitPointXYZ(ref float outX, ref float outY, ref float outZ) {}

void zbtGetRayTestHitPoint(xptr outPosition) {}

void zbtGetRayTestHitNormalXYZ(ref float outX, ref float outY, ref float outZ) {}

void zbtGetRayTestHitNormal(xptr outNormal) {}]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary Comment="Globals">
      <Source>
<![CDATA[// CONSTANTS

// boolean
const int FALSE = 0;
const int TRUE = 1;

// goniometric
const float PIx2 = PI * 2.0;
const float PI2 = PI / 2.0;
const float ROT90 = 0.25;
const float ROT45 = 0.125;

// application-specific
const int NUMBER_OF_SCENES = 4;
const float DEFAULT_DAMPING = 0.1;

// shape types
const int NUMBER_OF_SHAPES = 13;
const int CUBE1_SHAPE = 0;
const int CUBE2_SHAPE = 1;
const int CUBE3_SHAPE = 2;
const int CUBE4_SHAPE = 3;
const int CYLINDER1_SHAPE = 4;
const int CYLINDER2_SHAPE = 5;
const int CYLINDER3_SHAPE = 6;
const int CYLINDER4_SHAPE = 7;
const int CONE_SHAPE = 8;
const int DOMINO_SHAPE = 9;
const int KAPLA_SHAPE = 10;
const int SPHERE_SHAPE = 11;
const int SCALABLE_SPHERE_SHAPE = 12;

// VARIABLES

int Scene;
int IsClicked;
int WasClicked;

// object creation property setters
int ObjectType;
vec3 ObjectPosition;
vec3 ObjectRotation;
vec3 ObjectScale;
vec3 ObjectColor;
float ObjectMass;
float ObjectLinearDamping;
float ObjectAngularDamping;
int ObjectActivationState;

// collision shape IDs
xptr[NUMBER_OF_SHAPES] Shape;

// FUNCTIONS

// create standardized collision shape
xptr createCollisionShape(int type){

  switch(type){
    case CUBE1_SHAPE: return zbtCreateBoxShape(1, 1, 1);
    case CUBE2_SHAPE: return zbtCreateBoxShape(1, 2, 1);
    case CUBE3_SHAPE: return zbtCreateBoxShape(1, 3, 1);
    case CUBE4_SHAPE: return zbtCreateBoxShape(1, 4, 1);
    case CYLINDER1_SHAPE: return zbtCreateCylinderShape(1, 1);
    case CYLINDER2_SHAPE: return zbtCreateCylinderShape(1, 2);
    case CYLINDER3_SHAPE: return zbtCreateCylinderShape(1, 3);
    case CYLINDER4_SHAPE: return zbtCreateCylinderShape(1, 4);
    case CONE_SHAPE: return zbtCreateConeShape(1, 2);
    case DOMINO_SHAPE: return zbtCreateBoxShape(1, 2, 0.2);
    case KAPLA_SHAPE: return zbtCreateBoxShape(0.75, 3.75, 0.25);
    case SPHERE_SHAPE: return zbtCreateSphereShape(1.0);
    case SCALABLE_SPHERE_SHAPE: return zbtCreateScalableSphereShape(1.0);
  }
}]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="Init">
      <Expression>
<![CDATA[// init random seed
setRandomSeed(getSystemTime());

// init physical world
zbtCreateWorld();
zbtSetWorldGravity(0, -10, 0);

// init collision shapes
for(int i = 0; i < NUMBER_OF_SHAPES; ++i)
  Shape[i] = createCollisionShape(i);

// create ground
// worse performance for many objects
//xptr sh = zbtCreateStaticPlaneShape(0,1,0,0);
//xptr rb = zbtCreateRigidBodyXYZ(0, sh, 0, 0, 0, 0, 0, 0);
// use the following instead:
xptr sh = zbtCreateBoxShape(200,1,200);
xptr rb = zbtCreateRigidBodyXYZ(0, sh, 0, -1, 0, 0, 0, 0);
zbtSetFriction(rb, 1.0);

// init scene
Scene = -1;
WasClicked = FALSE;]]>
      </Expression>
    </ZExpression>
    <CallComponent Component="InitScene"/>
  </OnLoaded>
  <OnUpdate>
    <ZExpression Comment="Update simulation">
      <Expression>
<![CDATA[// simulation step
float t = App.DeltaTime;
zbtStepSimulation(t, 0, 0);

// rotate camera
t = App.Time / 30;
App.CameraPosition.X = cos(t * PIx2) * 60;
App.CameraPosition.Z = sin(t * PIx2) * 60;
App.CameraRotation.Y = t - ROT90;

//reset click flag
IsClicked = FALSE;]]>
      </Expression>
    </ZExpression>
    <KeyPress Comment="LMB press or touch" Keys="{">
      <OnPressed>
        <ZExpression Expression="IsClicked = TRUE;"/>
      </OnPressed>
    </KeyPress>
    <Condition>
      <Expression>
<![CDATA[int r = WasClicked && ! IsClicked;
WasClicked = IsClicked;
return r;]]>
      </Expression>
      <OnTrue>
        <ZExpression Name="InitScene">
          <Expression>
<![CDATA[@RemoveAllModels();

int shooting = FALSE;

// next scene
if(++Scene == NUMBER_OF_SCENES) Scene = 0;

// set comon properties
ObjectScale = vector3(1, 1, 1);

// build a brick formation
switch(Scene){

  case 0: // build box

    ObjectType = CYLINDER2_SHAPE;
    ObjectMass = 0.1;
    ObjectActivationState = FALSE;
    ObjectLinearDamping = ObjectAngularDamping = DEFAULT_DAMPING;
    ObjectRotation = vector3(0, 0, 0);

    for(int i = 1; i < 6; i++)
      for(int j = 0; j < 5; j++)
        for(int k = 0; k < 5; k++){

          // set position
          ObjectPosition = vector3(j * 3 - 6, i * 4 - 2, k * 3 - 6);

          // set color
          ObjectColor = vector3(0.5 + 0.2 * i, 0.3 + 0.1 * j, 1 - 0.2 * k);

          // spawn
          createModel(ObjectModel);
        }

    // init shooting
    shooting = TRUE;

    break;

  case 1: // build dominoes

    float x = -20;
    float z = 0;
    float a = 0;

    // set commmon properties
    ObjectType = DOMINO_SHAPE;
    ObjectMass = 0.1;
    ObjectActivationState = TRUE;
    ObjectLinearDamping = ObjectAngularDamping = 0;
    ObjectPosition = vector3(x, 2.1, z - 1.5);
    ObjectRotation = vector3(0.05, 0, 0);

    for(int i = 100; i > 50; i--){

      ObjectColor = vector3(
        frac(i/2.0) < 0.5 ? 1 - (i-50) / 100.0: 0,
        (i-50) / 50.0,
        frac(i/2.0) >= 0.5 ? 0.8 - (i-50) / 300.0: 0);

      // spawn
      createModel(ObjectModel);

      ObjectPosition.X = x;
      ObjectPosition.Z = z;
      ObjectRotation.X = 0;
      ObjectRotation.Y = a;
      ObjectActivationState = FALSE;

      a += 2.2 / i;
      x += sin(a*PIx2) * 3;
      z += cos(a*PIx2) * 3;
    }

    break;

  case 2: // castle

    // set commmon properties
    ObjectMass = 0.3;
    ObjectActivationState = FALSE;
    ObjectLinearDamping = DEFAULT_DAMPING;
    ObjectAngularDamping = DEFAULT_DAMPING;
    ObjectRotation = vector3(0, 0, 0);

    // main pillars
    ObjectType = CYLINDER2_SHAPE;
    ObjectColor = vector3(1, 1, 0);
    // 1st
    ObjectPosition = vector3(3, 2, 3);
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.X = -3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.X = 3;
    createModel(ObjectModel);

    // side smaller pillars
    ObjectType = CYLINDER1_SHAPE;
    ObjectColor = vector3(0, 0.5, 1);
    // 1st
    ObjectPosition = vector3(5, 1, 3);
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 3nd
    ObjectPosition.X = 9;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 5th
    ObjectPosition.X = -5;
    createModel(ObjectModel);
    // 6th
    ObjectPosition.Z=-3;
    createModel(ObjectModel);
    // 7th
    ObjectPosition.X=-9;
    createModel(ObjectModel);
    // 8th
    ObjectPosition.Z=3;
    createModel(ObjectModel);

    // main horizontal beams
    ObjectType = CUBE4_SHAPE;
    ObjectRotation.Z = ROT90;
    ObjectColor = vector3(1, 0.2, 0);
    // 1st
    ObjectPosition.X = 0;
    ObjectPosition.Y = 5;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z=-3;
    createModel(ObjectModel);

    // side horizontal beams
    ObjectType = CUBE3_SHAPE;
    ObjectColor = vector3(0, 1, 0.2);
    // 1st
    ObjectPosition.X = 7;
    ObjectPosition.Y = 3;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z=3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.X = -7;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.Z=-3;
    createModel(ObjectModel);

    // main 2nd-level beams
    ObjectType = CUBE4_SHAPE;
    ObjectColor = vector3(1, 0.2, 1);
    ObjectRotation.Y = ROT90;
    // 1st
    ObjectPosition = vector3(1, 7, 0);
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.X = -1;
    createModel(ObjectModel);

    // gable
    ObjectType = CONE_SHAPE;
    ObjectColor = vector3(1, 1, 0);
    ObjectRotation.X = 0;
    ObjectRotation.Y = 0;
    ObjectRotation.Z = 0;
    // 1st
    ObjectPosition = vector3(0, 9, 3);
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z = -3;
    createModel(ObjectModel);

    // low tower
    ObjectType = CUBE2_SHAPE;
    ObjectColor = vector3(0, 0.5, 1);
    // 1st
    ObjectPosition = vector3(3, 8, 3);
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.X = -3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.X = 3;
    createModel(ObjectModel);

    // up tower
    ObjectType = CYLINDER2_SHAPE;
    ObjectColor = vector3(0, 1, 0.2);
    // 1st
    ObjectPosition.Y = 12;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.X = -3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.X = 3;
    createModel(ObjectModel);

    // roof
    ObjectType = CONE_SHAPE;
    ObjectColor = vector3(1, 0.2, 0);
    // 1st
    ObjectPosition.Y = 15;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.X = -3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.X = 3;
    createModel(ObjectModel);

    // side walls
    ObjectType = CUBE2_SHAPE;
    ObjectColor = vector3(1, 1, 0);
    ObjectRotation.Y = ROT45;
    // 1st
    ObjectPosition.X = 5.5;
    ObjectPosition.Y = 6;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.X = -5.5;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 5th
    ObjectType = CUBE1_SHAPE;
    ObjectColor = vector3(1, 0, 1);
    ObjectPosition.X = 8.5;
    ObjectPosition.Y = 5;
    createModel(ObjectModel);
    // 6th
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 7th
    ObjectPosition.X = -8.5;
    createModel(ObjectModel);
    // 8th
    ObjectPosition.Z = -3;
    createModel(ObjectModel);

    // side roofs
    ObjectType = CONE_SHAPE;
    ObjectColor = vector3(1, 0.2, 0);
    // 1st
    ObjectPosition.X = 5.5;
    ObjectPosition.Y = 9;
    createModel(ObjectModel);
    // 2nd
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 3rd
    ObjectPosition.X = -5.5;
    createModel(ObjectModel);
    // 4th
    ObjectPosition.Z = -3;
    createModel(ObjectModel);
    // 5th
    ObjectPosition.X = 8.5;
    ObjectPosition.Y = 7;
    createModel(ObjectModel);
    // 6th
    ObjectPosition.Z = 3;
    createModel(ObjectModel);
    // 7th
    ObjectPosition.X = -8.5;
    createModel(ObjectModel);
    // 8th
    ObjectPosition.Z = -3;
    createModel(ObjectModel);

    // init shooting
    shooting = TRUE;

    break;

  case 3: // build tower

    ObjectType = CUBE1_SHAPE;
    ObjectMass = 0.5;
    ObjectActivationState = TRUE;
    ObjectLinearDamping = ObjectAngularDamping = DEFAULT_DAMPING;
    ObjectRotation.X = 0;
    ObjectRotation.Z = 0;

    for(int i = 0; i < 20; i++){

      ObjectColor = vector3(1 - 0.025 * i, 0.25 + 0.05 * i, 0);

      for(float j = 0; j < 1; j+= 0.1){

          ObjectPosition = vector3(
            cos(j*PIx2 + i*PI2) * 5,
            i * 2.01 + 30,
            sin(j*PIx2 + i*PI2) * 5);
          ObjectRotation.Y = atan2(ObjectPosition.X, ObjectPosition.Z) / PIx2;

          // spawn
          createModel(ObjectModel);
        }
    }

    // init shooting
    shooting = FALSE;
}

if(shooting){
  model m;

  // set color
  ObjectColor = vector3(0.3, 0.1, 0);

  // set position
  ObjectPosition = vector3(20, 3, -20);

  // set physical properties
  ObjectType = SPHERE_SHAPE;
  ObjectMass = 2;

  // spawn
  m = createModel(ObjectModel);

  // set velocity
  zbtSetLinearVelocity(m.Body, -25, 8, 25);
}]]>
          </Expression>
        </ZExpression>
      </OnTrue>
    </Condition>
  </OnUpdate>
  <OnRender>
    <RenderTransformGroup Comment="Sky" Scale="150 100 150" Translate="0 15 0">
      <Children>
        <UseMaterial Material="SkyMaterial"/>
        <RenderMesh Mesh="SphereMesh"/>
      </Children>
    </RenderTransformGroup>
    <RenderTransformGroup Comment="Ground" Scale="120 120 1" Translate="0 -0.3 0" Rotate="-0.25 0 0">
      <Children>
        <UseMaterial Material="GroundMaterial"/>
        <RenderSprite/>
      </Children>
    </RenderTransformGroup>
    <UseMaterial Material="DigitsMaterial"/>
    <RenderText Comment="FPS" TextFloatRef="App.FpsCounter" X="-0.97" Y="0.9" Scale="0.5" Align="1"/>
  </OnRender>
  <OnClose>
    <ZExpression>
      <Expression>
<![CDATA[// destroy physical world
zbtDestroyWorld();]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Lights>
    <Light Position="50 50 50" Color="1 1 0 1" Kind="1"/>
    <Light Position="-50 50 -50" Color="1 0.502 0 1" Kind="1"/>
  </Lights>
  <Content>
    <Group Comment="Artwork">
      <Children>
        <Group Comment="Meshes">
          <Children>
            <Mesh Name="Cube1Mesh">
              <Producers>
                <MeshBox/>
              </Producers>
            </Mesh>
            <Mesh Name="Cube2Mesh">
              <Producers>
                <MeshBox Scale="1 2 1"/>
              </Producers>
            </Mesh>
            <Mesh Name="Cube3Mesh">
              <Producers>
                <MeshBox Scale="1 3 1"/>
              </Producers>
            </Mesh>
            <Mesh Name="Cube4Mesh">
              <Producers>
                <MeshBox Scale="1 4 1"/>
              </Producers>
            </Mesh>
            <Mesh Name="Cylinder1Mesh">
              <Producers>
                <MeshBox Scale="1 0.5 1" XCount="18" YCount="2" Grid2DOnly="255"/>
                <MeshExpression AutoNormals="0">
                  <Expression>
<![CDATA[float k;
if(abs(v.Y) < 0.5){
  k = v.X * PI;
  v.X = sin(k);
  v.Z = cos(k);
} else {
  v.X = 0;
  v.Z = 0;
}

v.Y = v.Y < 0 ? -1 : 1;

n.X = v.X;
n.Y = v.Y;
n.Z = v.Z;



/*//

        float E, A, C, X, Y, Z;

        // Convert range to radians

        E = v.Y*PI; // Elevation
        A = v.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        C = cos(E);

        X = sin(A)*C;
        Y = sin(E);
        Z = cos(A)*C;

        // Assign coordinates

        v.X = X;
        v.Y = Y;
        v.Z = Z;
        v.Y = v.Y > 0 ? 1 : -1;

        n.X = X;
        n.Y = Y;
        n.Z = Z;
 */]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="Cylinder2Mesh">
              <Producers>
                <MeshBox Scale="1 0.5 1" XCount="18" YCount="2" Grid2DOnly="255"/>
                <MeshExpression Scale="1 2 1" AutoNormals="0">
                  <Expression>
<![CDATA[float k;
if(abs(v.Y) < 0.5){
  k = v.X * PI;
  v.X = sin(k);
  v.Z = cos(k);
} else {
  v.X = 0;
  v.Z = 0;
}

v.Y = v.Y < 0 ? -1 : 1;

n.X = v.X;
n.Y = v.Y;
n.Z = v.Z;



/*//

        float E, A, C, X, Y, Z;

        // Convert range to radians

        E = v.Y*PI; // Elevation
        A = v.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        C = cos(E);

        X = sin(A)*C;
        Y = sin(E);
        Z = cos(A)*C;

        // Assign coordinates

        v.X = X;
        v.Y = Y;
        v.Z = Z;
        v.Y = v.Y > 0 ? 1 : -1;

        n.X = X;
        n.Y = Y;
        n.Z = Z;
 */]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="Cylinder3Mesh">
              <Producers>
                <MeshBox Scale="1 0.5 1" XCount="18" YCount="2" Grid2DOnly="255"/>
                <MeshExpression Scale="1 3 1" AutoNormals="0">
                  <Expression>
<![CDATA[float k;
if(abs(v.Y) < 0.5){
  k = v.X * PI;
  v.X = sin(k);
  v.Z = cos(k);
} else {
  v.X = 0;
  v.Z = 0;
}

v.Y = v.Y < 0 ? -1 : 1;

n.X = v.X;
n.Y = v.Y;
n.Z = v.Z;



/*//

        float E, A, C, X, Y, Z;

        // Convert range to radians

        E = v.Y*PI; // Elevation
        A = v.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        C = cos(E);

        X = sin(A)*C;
        Y = sin(E);
        Z = cos(A)*C;

        // Assign coordinates

        v.X = X;
        v.Y = Y;
        v.Z = Z;
        v.Y = v.Y > 0 ? 1 : -1;

        n.X = X;
        n.Y = Y;
        n.Z = Z;
 */]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="Cylinder4Mesh">
              <Producers>
                <MeshBox Scale="1 0.5 1" XCount="18" YCount="2" Grid2DOnly="255"/>
                <MeshExpression Scale="1 4 1" AutoNormals="0">
                  <Expression>
<![CDATA[float k;
if(abs(v.Y) < 0.5){
  k = v.X * PI;
  v.X = sin(k);
  v.Z = cos(k);
} else {
  v.X = 0;
  v.Z = 0;
}

v.Y = v.Y < 0 ? -1 : 1;

n.X = v.X;
n.Y = v.Y;
n.Z = v.Z;



/*//

        float E, A, C, X, Y, Z;

        // Convert range to radians

        E = v.Y*PI; // Elevation
        A = v.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        C = cos(E);

        X = sin(A)*C;
        Y = sin(E);
        Z = cos(A)*C;

        // Assign coordinates

        v.X = X;
        v.Y = Y;
        v.Z = Z;
        v.Y = v.Y > 0 ? 1 : -1;

        n.X = X;
        n.Y = Y;
        n.Z = Z;
 */]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
            <Mesh Name="ConeMesh">
              <Producers>
                <MeshSphere ZSamples="3" RadialSamples="18"/>
                <MeshTransform Rotation="0.25 0 0"/>
                <MeshExpression Expression="v.Y = v.Y &lt; 0.5 ? -1 : 1;"/>
              </Producers>
            </Mesh>
            <Mesh Name="DominoMesh">
              <Producers>
                <MeshBox Scale="1 2 0.2"/>
              </Producers>
            </Mesh>
            <Mesh Name="KaplaMesh">
              <Producers>
                <MeshBox Scale="0.75 3.75 0.25"/>
              </Producers>
            </Mesh>
            <Mesh Name="SphereMesh">
              <Producers>
                <MeshBox Scale="1 0.5 1" XCount="18" YCount="12" Grid2DOnly="255"/>
                <MeshExpression AutoNormals="0">
                  <Expression>
<![CDATA[//

        float E, A, K, X, Y, Z;

        // Convert range to radians

        E = v.Y*PI; // Elevation
        A = v.X*PI; // Azimuth

        // Convert spherical coordinates into cartesian

        K = cos(E);

        X = sin(A)*K;
        Y = sin(E);
        Z = cos(A)*K;

        // Assign coordinates

        v.X = X;
        v.Y = Y;
        v.Z = Z;

        n.X = X;
        n.Y = Y;
        n.Z = Z;]]>
                  </Expression>
                </MeshExpression>
              </Producers>
            </Mesh>
          </Children>
        </Group>
        <Group Comment="Bitmaps and Materials">
          <Children>
            <Material Name="ObjectMaterial" WireframeWidth="0" SpecularColor="0 0 0 1" EmissionColor="0 0 0 1" Blend="1"/>
            <Bitmap Name="GroundBitmap">
              <Producers>
                <BitmapExpression UseBlankSource="1" Expression="pixel = x &gt; 0.98 || y &gt; 0.98 ? 1 : 0;"/>
              </Producers>
            </Bitmap>
            <Material Name="GroundMaterial" WireframeWidth="1" Shading="1" Color="0 1 0 0.5" Blend="2">
              <Textures>
                <MaterialTexture Texture="GroundBitmap" TextureScale="10 10 1" TextureWrapMode="1" TexCoords="1"/>
              </Textures>
            </Material>
            <Bitmap Name="SkyBitmap" Width="0" Height="3" Filter="2">
              <Producers>
                <BitmapFromFile Comment="Imported from sky.png" DataWidth="16" DataHeight="128">
                  <BitmapFile>
<![CDATA[78DAB5D8F946C4511806E0F67D99F67ED7111189212211318C88884444242212119188881111912122464444222212119168DFF7BDAEE1F9239E0B98E59CEFBCDF1B54FD06A4DA54D6FC985A535187C2DFA6DE94377C994653D6849A3F4D8B298D7C98A82969456DEFA6DD1477BC994E53D485BA5F4D8F09F5BE983E53D88F069ECDA029187A32C3267F048D3E9A319337FE60264CEE249ABA37D326277667664CF62C9ABB35F3266BE1C6C44DE6225ABA36CB26237165564CFA2A5ABB34EB266DE3C26C9AD42DB47D6E764CCAEE99D933C9FBE8E0D41C9AA4A31373FCCFF0F3E8F7E5DF13FF2F3D0F7ADEF43CF37DC1FBA8F75DE789CE2B9E87386F759EEB7BA1EF11BF77F89EEA7BAD7940F306E719CC4B9AC734EF699EE4BC8A7958F3B6E679DD17781FC17D47F729DDD7741FE47D13F759DD97751FD77D9FFB04EC2BB40FD1BE45FB1CEE8BB08FD2BE4BFB34EDEBB80FC4BE51FB4CED4BB58FE5BE17FB64EDABB50FD7BE3DC03EFF0FB9DE52F5]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Material Name="SkyMaterial" WireframeWidth="0" Light="0" SpecularColor="0 0 0 1" EmissionColor="0 0 0 1" DrawBackFace="255">
              <Textures>
                <MaterialTexture Texture="SkyBitmap" TextureScale="1 1 0" TextureY="0.05" TexCoords="1" Origin="0 0 0"/>
              </Textures>
            </Material>
            <Bitmap Name="DigitsBitmap" Width="3" Height="0">
              <Producers>
                <BitmapFromFile Comment="Imported from Digits.bmp" Transparency="1" DataWidth="128" DataHeight="16">
                  <BitmapFile>
<![CDATA[78DAED583BAE22410C7CC7E5101C8113700172726252524242324232B6F44A2A59FEB567B52BBDE07580861EB7DB2E7FBA7ABEBE7EC78F1897CBE5F57A7D3E1FFCE2B91786D8E3F18893D590CCF97CC642CD3F9FCFEBF5BAB48D4BEC4CD4839974EDF1789464E51A0576BB5D65005EDD6E37E2433DF8EBE4DFEFB7DEDEEFF7C3E130071FDAB010AB601E8DC1F356FC018294B861171273CE431833B07CBFDF6FC29F7AA49F5BE3D72DC446825DAE45316085798090EECEB73012028DD9720A0F8C54A530D56F01A7FE268229FE0C410F66CCB1D3E9B40C77C43FEA41FE43C6C69A7E39B4A3D8B204185CE714FE5620D88D26D5CDE4B7FAA9BC095FB335430054E7D5C7CAB59DD00DA6932BA5D42A483ABF22A4D8CE8A2D4BA0723666C512D86176A9C0FF027F25CC3C048477728EF4FE3A475EDF638E1BE6119AD4BC743E8D63AC916509B095F539B909FF4D2188FD070663779BB7CB4CB381ABCAA10AB72B815862B4D095065BB47590673471E3613101AA92E95D9EA86508403F52AE65CFCDA80A10D9C909FED0E65062381C9EF1B09B9400BC787F0F9ACD670B3E529DC8EB14862A7AB7B4FC3FE1AFCA8D1D58CD046FD3F2244AA294D1189210174797EDA2A6582E66D2D3ADAA0498DEE29F919CA48C852931C1FF9FF79F09AF636933461110DB8552FEC92414C815A5E13968DB42C3F3AB12607A33FF510BD1E6ADBD2E368A4D080FF1671CD38AB679556953178AF833ABFBAD99ED9BEE415509D000011E6D6E5CE8CFE84DFC1356B1E9CDF14F833B942114D831E28F99A55FF4A2BF59546D33B632E76FE45A31CD18A6E52D6C7EFF62A4C80722FEF0D735732260792C661C29A24C0526BB508AFF8411B104969F5352C263ED8C55EC66D8EADD3710E6D5A40009B8FDFE50458DD7BA147FDAA07B3AA17314881104DAE409926998AA4EBD14D8EA4347DC515F0F6C925C8AE1524233EE3E18D1D6594F99C9FD575B108AE5F7B72AFF594A3AEC18D0187DF513C9A41CD59567E43FF3DB19346017C5D1E6EDFCAE0723C527F190268C60273EBD5FBFE3278C3FFC4DB206]]>
                  </BitmapFile>
                </BitmapFromFile>
              </Producers>
            </Bitmap>
            <Font Name="DigitsFont" Bitmap="DigitsBitmap" FirstChar="48" CharPixelWidth="12" CharPixelHeight="16"/>
            <Material Name="DigitsMaterial" Light="0" Blend="2" Font="DigitsFont"/>
          </Children>
        </Group>
      </Children>
    </Group>
    <Model Name="ObjectModel" Position="-33.7846 3.3394 11.3442" Category="1" RenderOrder="1">
      <Definitions>
        <Variable Name="Body" Type="9"/>
        <Variable Name="ObjectShape" Type="9"/>
      </Definitions>
      <OnSpawn>
        <ZExpression Comment="Init">
          <Expression>
<![CDATA[xptr sh, rb;
int isScaled = ObjectScale.X != 1 || ObjectScale.Y != 1 || ObjectScale.Z != 1;

// set properties from object setters
CurrentModel.Position = ObjectPosition;
CurrentModel.Rotation = ObjectRotation;

// select/create shape
if(isScaled){
  sh = createCollisionShape(ObjectType);
  zbtSetShapeLocalScaling(sh, ObjectScale.X, ObjectScale.Y, ObjectScale.Z);
  ObjectShape = sh;
  CurrentModel.Scale = ObjectScale;
} else {
  sh = Shape[ObjectType];
  ObjectShape = null;
}

// select mesh
switch(ObjectType){

  case CUBE1_SHAPE:
    ModelMesh.Mesh = Cube1Mesh;
    break;

  case CUBE2_SHAPE:
    ModelMesh.Mesh = Cube2Mesh;
    break;

  case CUBE3_SHAPE:
    ModelMesh.Mesh = Cube3Mesh;
    break;

  case CUBE4_SHAPE:
    ModelMesh.Mesh = Cube4Mesh;
    break;

  case CYLINDER1_SHAPE:
    ModelMesh.Mesh = Cylinder1Mesh;
    break;

  case CYLINDER2_SHAPE:
    ModelMesh.Mesh = Cylinder2Mesh;
    break;

  case CYLINDER3_SHAPE:
    ModelMesh.Mesh = Cylinder3Mesh;
    break;

  case CYLINDER4_SHAPE:
    ModelMesh.Mesh = Cylinder4Mesh;
    break;

  case CONE_SHAPE:
    ModelMesh.Mesh = ConeMesh;
    break;

  case DOMINO_SHAPE:
    ModelMesh.Mesh = DominoMesh;
    break;

  case KAPLA_SHAPE:
    ModelMesh.Mesh = KaplaMesh;
    break;

  case SPHERE_SHAPE:
    ModelMesh.Mesh = SphereMesh;
    break;

  case SCALABLE_SPHERE_SHAPE:
    ModelMesh.Mesh = SphereMesh;
}

// create rigid body
Body = zbtCreateRigidBody(ObjectMass, sh, ObjectPosition, ObjectRotation);

// set physical properties
zbtSetDamping(Body, ObjectLinearDamping, ObjectAngularDamping);
zbtSetActivationState(Body, ObjectActivationState);

// set color and texture
BrickColor.Color = ObjectColor;]]>
          </Expression>
        </ZExpression>
      </OnSpawn>
      <OnUpdate>
        <ZExpression Comment="Update position and rotation" Expression="zbtGetPosRot(Body, CurrentModel.Position, CurrentModel.Rotation);"/>
      </OnUpdate>
      <OnRender>
        <UseMaterial Material="ObjectMaterial"/>
        <RenderSetColor Name="BrickColor" Color="0.9404 0.2947 0.476 1"/>
        <RenderMesh Name="ModelMesh" Mesh="Cube1Mesh"/>
      </OnRender>
      <OnRemove>
        <ZExpression Comment="Delete rigid body and shape">
          <Expression>
<![CDATA[zbtDeleteRigidBody(Body);
//if(ObjectShape != null) zbtDeleteShape(ObjectShape);]]>
          </Expression>
        </ZExpression>
      </OnRemove>
    </Model>
  </Content>
</ZApplication>
